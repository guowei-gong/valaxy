---
title: 位运算符优化计数程序
date: 2022-11-08 10:59:30
tags: 
    - 算法
    - Leetcode
categories: 算法虐我千百遍，我待算法如初恋
---

巧妙的通过整数，来表示每个字符串中出现过哪些字符

# 思路
## 思路一
通过数组记录 `allowed` 中的字符，遍历 `words` 字符串数组，获取数组中的字符串，判断该字符串的每一个字符，是否在 `allowed` 中存在，如果存在，返回结果加一。
## 思路二
通过整数，来表示每个字符串中出现过哪些字符，判断字符串转换得到的整数，与 `allowed` 转换得到的整数是否相同，相同返回结果加一。

# 解题方法
## 思路一
略
## 思路二
> 你可以先跳过解题方法，看代码，如果无法理解，再回过头来看看解题方法。

```Go []
var s string
s := ab

f := func(w string) (mask int) {
		for _, c := range w {
			// mask |= 1 << (c - 'a') 分解为如下三步
			tmp := c - 'a'
			left := 1 << tmp
			mask = (left | mask) + mask
		}
		return
	}

mask := f(s)
```
`tmp := c - 'a'`，`c` 变量是 `int32` 类型，也就是字符。`c - 'a'`，根据 ASCII 码表，`a = 97`，那么实际上是`tmp = 97 - 97 // output: 0`，通过左移运算符 `<<`，`left := 1 << 0 // output: 1`，最后 `mask = (1 | 0) + 0 // output: 1`。

> 🍉 小贴士：什么是`<<` 左移运算符？
> 例如 A << 3，A = 60
> 看到 A << 3，根据 `<<`，把式子看做左、右两个部分。左边，被左移的数字；右边，决定左边的数字移多少。
> 3 则代表 3 位。A 则变为 480，因为 `A = 60` => `A = 60 x 2 的 3 次方` => `A = 60 x 8 = 480`。

接着循环，最后就可以得到字符串 `s` 为 3，你可以自己推演一遍。

假如现在`s := aaab` 呢？答案仍然是 3，为什么？因为 `|` 位或运算符，如果是两个相同的二进制数，不管 `|` 多少次，结果仍不变，例如：
```Go []
a := 1
fmt.Println(strconv.FormatInt(int64(a), 2)) // output: 01，这是 a 的二进制
b := 2
fmt.Println(strconv.FormatInt(int64(b), 2)) // output: 10
c := a | b
fmt.Println("ans:", ans) // output: 3
fmt.Println(strconv.FormatInt(int64(ans), 2)) // output: 11。
// 为什么 c 等于 3？
// 因为 01 | 10 -> 11 -> 11 的十进制 -> 3
```
回到我们的例子 `s := aaab`，将 `a` 转化为整数 97，我们将它减去 97，输出 0（这是为了方便我们从 0 开始计算，即 `输入的字符 - 'a'`，不减去 97，即不减 a ，当然也可以，但是表示 26 个英文字母，是从 0 ~ 26 方便理解，还是 97 ~ 123 呢），1 左移 0 位后为 1，1 的二进制表达为 1，我们 `mask = mask | left + mask => 0 | 1 + 0 => 1`，此时 `s` 后面的字符串，不管有多少个 a，最后都是 ` 1 | 1`，那说明多个同样的字符，除了第一次从 0 值变了，后面 `mask` 的结果都是是不变的。

这样就完成了**通过整数来表示哪些字符出现过**。

# 时间复杂度
思路二相比思路一，时间复杂度没有变化，都是 O(m)，m 为所有字符串的总长度。
空间复杂度，前者为 O(C)，C 为 allowed 字符集的大小，后者为 O(1)。

# Code
## 思路一
```Go []
func countConsistentStrings(allowed string, words []string) (ans int) {
	s := [26]bool{}
	for _, c := range allowed {
		s[c-'a'] = true
	}
	
	check := func(w string) bool {
		for _, c := range w {
			if !s[c-'a'] {
				return false
			}
		}
		return true
	}
	
	for _, w := range words {
		if check(w) {
			ans++
		}
	}
	
	return ans
}
```
## 思路二
```Go []
func countConsistentStrings(allowed string, words []string) (ans int) {
	f := func(w string) (mask int) {
		for _, c := range w {
			mask |= 1 << (c - 'a')
		}
		return 
	}
	
	mask := f(allowed)
	for _, w := range words {
		if (mask | f(w)) == mask {
			ans++
		}
	}
	return
}
```

# 引用
感谢 [@ylb](https://leetcode.cn/u/lcbin/) 提供的解题思路。他的[题解链接](https://leetcode.cn/problems/count-the-number-of-consistent-strings/solutions/1955937/by-lcbin-2w0y/)。